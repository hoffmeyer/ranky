{"version":3,"file":"bundle.js","names":[],"mappings":"","sources":["bundle.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({\"./client/rankyui.js\":[function(require,module,exports){\ndocument.addEventListener('DOMContentLoaded', function(){\n  var hbsHelpers = require('./hbsHelpers.js'),\n      model = require('./model.js'),\n      observe = require('observe-js'),\n      routes = require('./routes/routes.js');\n\n  routes(document.getElementById('appContent'));\n\n\n  // populate model\n  request = new XMLHttpRequest();\n  request.open('GET', '/list', true);\n\n  request.onload = function() {\n    if (request.status >= 200 && request.status < 400){\n      data = JSON.parse(request.responseText);\n      model.players.push.apply(model.players, data);\n      Platform.performMicrotaskCheckpoint();\n    } else {\n        console.log('An error occurred while retreiving the list');\n    }\n  };\n\n  request.onerror = function() {\n      console.log('Something went very wrong while retreiving the list');\n  };\n\n  request.send();\n});\n\n},{\"./hbsHelpers.js\":\"/Users/hoffmeyer/development/ranky/client/hbsHelpers.js\",\"./model.js\":\"/Users/hoffmeyer/development/ranky/client/model.js\",\"./routes/routes.js\":\"/Users/hoffmeyer/development/ranky/client/routes/routes.js\",\"observe-js\":\"/Users/hoffmeyer/development/ranky/node_modules/observe-js/src/observe.js\"}],\"/Users/hoffmeyer/development/ranky/client/controller.js\":[function(require,module,exports){\nmodule.exports = {\n    newMatch : function(team1, team2){\n        console.log(team1, team2);\n    }\n}\n\n},{}],\"/Users/hoffmeyer/development/ranky/client/hbsHelpers.js\":[function(require,module,exports){\n\nmodule.exports = function(){\n    Handlebars = require('hbsfy/runtime');\n\n    Handlebars.registerHelper('inc', function(i){\n        return i+1;\n    });\n\n}();\n\n},{\"hbsfy/runtime\":\"/Users/hoffmeyer/development/ranky/node_modules/hbsfy/runtime.js\"}],\"/Users/hoffmeyer/development/ranky/client/model.js\":[function(require,module,exports){\nmodule.exports = {\n    players: []\n}\n\n},{}],\"/Users/hoffmeyer/development/ranky/client/newMatch.js\":[function(require,module,exports){\nvar formUtil = require('./util/formUtil'),\n    controller = require('./controller.js');\n\nmodule.exports = function(element) {\n    var tpl = require('../tpl/newMatch.hbs');\n\n    element.innerHTML = tpl();\n\n    var t1p1Input = document.getElementById('newMatch-team1-player1'),\n        t1p2Input = document.getElementById('newMatch-team1-player2'),\n        t1Score  = document.getElementById('newMatch-team1-score'),\n        t2p1Input = document.getElementById('newMatch-team2-player1'),\n        t2p2Input = document.getElementById('newMatch-team2-player2');\n        t2Score  = document.getElementById('newMatch-team2-score'),\n\n    document.getElementById('newMatch-btn').addEventListener('click', function(e){\n        var team1, team2;\n\n        e.preventDefault();\n\n        team1 = {\n            players: [\n                +t1p1Input.value,\n                +t1p2Input.value\n            ],\n            score: +t1Score.value\n        };\n\n        team2 = {\n            players: [\n                +t2p1Input.value,\n                +t2p2Input.value\n            ],\n            score: +t2Score.value\n        };\n\n        controller.newMatch(team1, team2);\n        formUtil.clearInputs(t1p1Input, t1p2Input, t1Score, t2p1Input, t2p2Input, t2Score);\n    });\n\n};\n\n},{\"../tpl/newMatch.hbs\":\"/Users/hoffmeyer/development/ranky/tpl/newMatch.hbs\",\"./controller.js\":\"/Users/hoffmeyer/development/ranky/client/controller.js\",\"./util/formUtil\":\"/Users/hoffmeyer/development/ranky/client/util/formUtil.js\"}],\"/Users/hoffmeyer/development/ranky/client/playerList.js\":[function(require,module,exports){\nvar model = require('./model.js'),\n    observe = require('observe-js');\n\nmodule.exports = function(element){\n    var listTpl = require('../tpl/playerList.hbs'),\n        playerObserver = new observe.ArrayObserver(model.players);\n\n    var update = function(){\n        element.innerHTML = listTpl(model.players);\n    }\n    update()\n    playerObserver.open(update);\n};\n\n},{\"../tpl/playerList.hbs\":\"/Users/hoffmeyer/development/ranky/tpl/playerList.hbs\",\"./model.js\":\"/Users/hoffmeyer/development/ranky/client/model.js\",\"observe-js\":\"/Users/hoffmeyer/development/ranky/node_modules/observe-js/src/observe.js\"}],\"/Users/hoffmeyer/development/ranky/client/routes/routes.js\":[function(require,module,exports){\nvar playerList = require('../playerList.js'),\n    newMatch = require('../newMatch.js');\n\nmodule.exports = function(element){\n\n    var updateContent = function() {\n        var url = window.location.hash.substr(1),\n            view;\n\n        switch(url){\n            case 'newMatch':\n                view = newMatch;\n                break;\n            default:\n                view = playerList;\n                break;\n        }\n        view(element);\n    };\n\n    window.onpopstate = function(){\n        updateContent();\n    };\n\n    updateContent();\n};\n\n},{\"../newMatch.js\":\"/Users/hoffmeyer/development/ranky/client/newMatch.js\",\"../playerList.js\":\"/Users/hoffmeyer/development/ranky/client/playerList.js\"}],\"/Users/hoffmeyer/development/ranky/client/util/formUtil.js\":[function(require,module,exports){\nmodule.exports = {\n    clearInputs: function(){\n        var args = Array.prototype.slice.call(arguments);\n        args.forEach(function(e, i){\n            if(e.tagName.toLowerCase() === \"input\"){\n                e.value = null;\n            }\n        });\n    }\n};\n\n},{}],\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars.runtime.js\":[function(require,module,exports){\n\"use strict\";\n/*globals Handlebars: true */\nvar base = require(\"./handlebars/base\");\n\n// Each of these augment the Handlebars object. No need to setup here.\n// (This is done to easily share code between commonjs and browse envs)\nvar SafeString = require(\"./handlebars/safe-string\")[\"default\"];\nvar Exception = require(\"./handlebars/exception\")[\"default\"];\nvar Utils = require(\"./handlebars/utils\");\nvar runtime = require(\"./handlebars/runtime\");\n\n// For compatibility and usage outside of module systems, make the Handlebars object a namespace\nvar create = function() {\n  var hb = new base.HandlebarsEnvironment();\n\n  Utils.extend(hb, base);\n  hb.SafeString = SafeString;\n  hb.Exception = Exception;\n  hb.Utils = Utils;\n  hb.escapeExpression = Utils.escapeExpression;\n\n  hb.VM = runtime;\n  hb.template = function(spec) {\n    return runtime.template(spec, hb);\n  };\n\n  return hb;\n};\n\nvar Handlebars = create();\nHandlebars.create = create;\n\nHandlebars['default'] = Handlebars;\n\nexports[\"default\"] = Handlebars;\n},{\"./handlebars/base\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/base.js\",\"./handlebars/exception\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/exception.js\",\"./handlebars/runtime\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/runtime.js\",\"./handlebars/safe-string\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/safe-string.js\",\"./handlebars/utils\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/utils.js\"}],\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/base.js\":[function(require,module,exports){\n\"use strict\";\nvar Utils = require(\"./utils\");\nvar Exception = require(\"./exception\")[\"default\"];\n\nvar VERSION = \"2.0.0\";\nexports.VERSION = VERSION;var COMPILER_REVISION = 6;\nexports.COMPILER_REVISION = COMPILER_REVISION;\nvar REVISION_CHANGES = {\n  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it\n  2: '== 1.0.0-rc.3',\n  3: '== 1.0.0-rc.4',\n  4: '== 1.x.x',\n  5: '== 2.0.0-alpha.x',\n  6: '>= 2.0.0-beta.1'\n};\nexports.REVISION_CHANGES = REVISION_CHANGES;\nvar isArray = Utils.isArray,\n    isFunction = Utils.isFunction,\n    toString = Utils.toString,\n    objectType = '[object Object]';\n\nfunction HandlebarsEnvironment(helpers, partials) {\n  this.helpers = helpers || {};\n  this.partials = partials || {};\n\n  registerDefaultHelpers(this);\n}\n\nexports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {\n  constructor: HandlebarsEnvironment,\n\n  logger: logger,\n  log: log,\n\n  registerHelper: function(name, fn) {\n    if (toString.call(name) === objectType) {\n      if (fn) { throw new Exception('Arg not supported with multiple helpers'); }\n      Utils.extend(this.helpers, name);\n    } else {\n      this.helpers[name] = fn;\n    }\n  },\n  unregisterHelper: function(name) {\n    delete this.helpers[name];\n  },\n\n  registerPartial: function(name, partial) {\n    if (toString.call(name) === objectType) {\n      Utils.extend(this.partials,  name);\n    } else {\n      this.partials[name] = partial;\n    }\n  },\n  unregisterPartial: function(name) {\n    delete this.partials[name];\n  }\n};\n\nfunction registerDefaultHelpers(instance) {\n  instance.registerHelper('helperMissing', function(/* [args, ]options */) {\n    if(arguments.length === 1) {\n      // A missing field in a {{foo}} constuct.\n      return undefined;\n    } else {\n      // Someone is actually trying to call something, blow up.\n      throw new Exception(\"Missing helper: '\" + arguments[arguments.length-1].name + \"'\");\n    }\n  });\n\n  instance.registerHelper('blockHelperMissing', function(context, options) {\n    var inverse = options.inverse,\n        fn = options.fn;\n\n    if(context === true) {\n      return fn(this);\n    } else if(context === false || context == null) {\n      return inverse(this);\n    } else if (isArray(context)) {\n      if(context.length > 0) {\n        if (options.ids) {\n          options.ids = [options.name];\n        }\n\n        return instance.helpers.each(context, options);\n      } else {\n        return inverse(this);\n      }\n    } else {\n      if (options.data && options.ids) {\n        var data = createFrame(options.data);\n        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);\n        options = {data: data};\n      }\n\n      return fn(context, options);\n    }\n  });\n\n  instance.registerHelper('each', function(context, options) {\n    if (!options) {\n      throw new Exception('Must pass iterator to #each');\n    }\n\n    var fn = options.fn, inverse = options.inverse;\n    var i = 0, ret = \"\", data;\n\n    var contextPath;\n    if (options.data && options.ids) {\n      contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';\n    }\n\n    if (isFunction(context)) { context = context.call(this); }\n\n    if (options.data) {\n      data = createFrame(options.data);\n    }\n\n    if(context && typeof context === 'object') {\n      if (isArray(context)) {\n        for(var j = context.length; i<j; i++) {\n          if (data) {\n            data.index = i;\n            data.first = (i === 0);\n            data.last  = (i === (context.length-1));\n\n            if (contextPath) {\n              data.contextPath = contextPath + i;\n            }\n          }\n          ret = ret + fn(context[i], { data: data });\n        }\n      } else {\n        for(var key in context) {\n          if(context.hasOwnProperty(key)) {\n            if(data) {\n              data.key = key;\n              data.index = i;\n              data.first = (i === 0);\n\n              if (contextPath) {\n                data.contextPath = contextPath + key;\n              }\n            }\n            ret = ret + fn(context[key], {data: data});\n            i++;\n          }\n        }\n      }\n    }\n\n    if(i === 0){\n      ret = inverse(this);\n    }\n\n    return ret;\n  });\n\n  instance.registerHelper('if', function(conditional, options) {\n    if (isFunction(conditional)) { conditional = conditional.call(this); }\n\n    // Default behavior is to render the positive path if the value is truthy and not empty.\n    // The `includeZero` option may be set to treat the condtional as purely not empty based on the\n    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.\n    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {\n      return options.inverse(this);\n    } else {\n      return options.fn(this);\n    }\n  });\n\n  instance.registerHelper('unless', function(conditional, options) {\n    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});\n  });\n\n  instance.registerHelper('with', function(context, options) {\n    if (isFunction(context)) { context = context.call(this); }\n\n    var fn = options.fn;\n\n    if (!Utils.isEmpty(context)) {\n      if (options.data && options.ids) {\n        var data = createFrame(options.data);\n        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);\n        options = {data:data};\n      }\n\n      return fn(context, options);\n    } else {\n      return options.inverse(this);\n    }\n  });\n\n  instance.registerHelper('log', function(message, options) {\n    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;\n    instance.log(level, message);\n  });\n\n  instance.registerHelper('lookup', function(obj, field) {\n    return obj && obj[field];\n  });\n}\n\nvar logger = {\n  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },\n\n  // State enum\n  DEBUG: 0,\n  INFO: 1,\n  WARN: 2,\n  ERROR: 3,\n  level: 3,\n\n  // can be overridden in the host environment\n  log: function(level, message) {\n    if (logger.level <= level) {\n      var method = logger.methodMap[level];\n      if (typeof console !== 'undefined' && console[method]) {\n        console[method].call(console, message);\n      }\n    }\n  }\n};\nexports.logger = logger;\nvar log = logger.log;\nexports.log = log;\nvar createFrame = function(object) {\n  var frame = Utils.extend({}, object);\n  frame._parent = object;\n  return frame;\n};\nexports.createFrame = createFrame;\n},{\"./exception\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/exception.js\",\"./utils\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/utils.js\"}],\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/exception.js\":[function(require,module,exports){\n\"use strict\";\n\nvar errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];\n\nfunction Exception(message, node) {\n  var line;\n  if (node && node.firstLine) {\n    line = node.firstLine;\n\n    message += ' - ' + line + ':' + node.firstColumn;\n  }\n\n  var tmp = Error.prototype.constructor.call(this, message);\n\n  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.\n  for (var idx = 0; idx < errorProps.length; idx++) {\n    this[errorProps[idx]] = tmp[errorProps[idx]];\n  }\n\n  if (line) {\n    this.lineNumber = line;\n    this.column = node.firstColumn;\n  }\n}\n\nException.prototype = new Error();\n\nexports[\"default\"] = Exception;\n},{}],\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/runtime.js\":[function(require,module,exports){\n\"use strict\";\nvar Utils = require(\"./utils\");\nvar Exception = require(\"./exception\")[\"default\"];\nvar COMPILER_REVISION = require(\"./base\").COMPILER_REVISION;\nvar REVISION_CHANGES = require(\"./base\").REVISION_CHANGES;\nvar createFrame = require(\"./base\").createFrame;\n\nfunction checkRevision(compilerInfo) {\n  var compilerRevision = compilerInfo && compilerInfo[0] || 1,\n      currentRevision = COMPILER_REVISION;\n\n  if (compilerRevision !== currentRevision) {\n    if (compilerRevision < currentRevision) {\n      var runtimeVersions = REVISION_CHANGES[currentRevision],\n          compilerVersions = REVISION_CHANGES[compilerRevision];\n      throw new Exception(\"Template was precompiled with an older version of Handlebars than the current runtime. \"+\n            \"Please update your precompiler to a newer version (\"+runtimeVersions+\") or downgrade your runtime to an older version (\"+compilerVersions+\").\");\n    } else {\n      // Use the embedded version info since the runtime doesn't know about this revision yet\n      throw new Exception(\"Template was precompiled with a newer version of Handlebars than the current runtime. \"+\n            \"Please update your runtime to a newer version (\"+compilerInfo[1]+\").\");\n    }\n  }\n}\n\nexports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial\n\nfunction template(templateSpec, env) {\n  /* istanbul ignore next */\n  if (!env) {\n    throw new Exception(\"No environment passed to template\");\n  }\n  if (!templateSpec || !templateSpec.main) {\n    throw new Exception('Unknown template object: ' + typeof templateSpec);\n  }\n\n  // Note: Using env.VM references rather than local var references throughout this section to allow\n  // for external users to override these as psuedo-supported APIs.\n  env.VM.checkRevision(templateSpec.compiler);\n\n  var invokePartialWrapper = function(partial, indent, name, context, hash, helpers, partials, data, depths) {\n    if (hash) {\n      context = Utils.extend({}, context, hash);\n    }\n\n    var result = env.VM.invokePartial.call(this, partial, name, context, helpers, partials, data, depths);\n\n    if (result == null && env.compile) {\n      var options = { helpers: helpers, partials: partials, data: data, depths: depths };\n      partials[name] = env.compile(partial, { data: data !== undefined, compat: templateSpec.compat }, env);\n      result = partials[name](context, options);\n    }\n    if (result != null) {\n      if (indent) {\n        var lines = result.split('\\n');\n        for (var i = 0, l = lines.length; i < l; i++) {\n          if (!lines[i] && i + 1 === l) {\n            break;\n          }\n\n          lines[i] = indent + lines[i];\n        }\n        result = lines.join('\\n');\n      }\n      return result;\n    } else {\n      throw new Exception(\"The partial \" + name + \" could not be compiled when running in runtime-only mode\");\n    }\n  };\n\n  // Just add water\n  var container = {\n    lookup: function(depths, name) {\n      var len = depths.length;\n      for (var i = 0; i < len; i++) {\n        if (depths[i] && depths[i][name] != null) {\n          return depths[i][name];\n        }\n      }\n    },\n    lambda: function(current, context) {\n      return typeof current === 'function' ? current.call(context) : current;\n    },\n\n    escapeExpression: Utils.escapeExpression,\n    invokePartial: invokePartialWrapper,\n\n    fn: function(i) {\n      return templateSpec[i];\n    },\n\n    programs: [],\n    program: function(i, data, depths) {\n      var programWrapper = this.programs[i],\n          fn = this.fn(i);\n      if (data || depths) {\n        programWrapper = program(this, i, fn, data, depths);\n      } else if (!programWrapper) {\n        programWrapper = this.programs[i] = program(this, i, fn);\n      }\n      return programWrapper;\n    },\n\n    data: function(data, depth) {\n      while (data && depth--) {\n        data = data._parent;\n      }\n      return data;\n    },\n    merge: function(param, common) {\n      var ret = param || common;\n\n      if (param && common && (param !== common)) {\n        ret = Utils.extend({}, common, param);\n      }\n\n      return ret;\n    },\n\n    noop: env.VM.noop,\n    compilerInfo: templateSpec.compiler\n  };\n\n  var ret = function(context, options) {\n    options = options || {};\n    var data = options.data;\n\n    ret._setup(options);\n    if (!options.partial && templateSpec.useData) {\n      data = initData(context, data);\n    }\n    var depths;\n    if (templateSpec.useDepths) {\n      depths = options.depths ? [context].concat(options.depths) : [context];\n    }\n\n    return templateSpec.main.call(container, context, container.helpers, container.partials, data, depths);\n  };\n  ret.isTop = true;\n\n  ret._setup = function(options) {\n    if (!options.partial) {\n      container.helpers = container.merge(options.helpers, env.helpers);\n\n      if (templateSpec.usePartial) {\n        container.partials = container.merge(options.partials, env.partials);\n      }\n    } else {\n      container.helpers = options.helpers;\n      container.partials = options.partials;\n    }\n  };\n\n  ret._child = function(i, data, depths) {\n    if (templateSpec.useDepths && !depths) {\n      throw new Exception('must pass parent depths');\n    }\n\n    return program(container, i, templateSpec[i], data, depths);\n  };\n  return ret;\n}\n\nexports.template = template;function program(container, i, fn, data, depths) {\n  var prog = function(context, options) {\n    options = options || {};\n\n    return fn.call(container, context, container.helpers, container.partials, options.data || data, depths && [context].concat(depths));\n  };\n  prog.program = i;\n  prog.depth = depths ? depths.length : 0;\n  return prog;\n}\n\nexports.program = program;function invokePartial(partial, name, context, helpers, partials, data, depths) {\n  var options = { partial: true, helpers: helpers, partials: partials, data: data, depths: depths };\n\n  if(partial === undefined) {\n    throw new Exception(\"The partial \" + name + \" could not be found\");\n  } else if(partial instanceof Function) {\n    return partial(context, options);\n  }\n}\n\nexports.invokePartial = invokePartial;function noop() { return \"\"; }\n\nexports.noop = noop;function initData(context, data) {\n  if (!data || !('root' in data)) {\n    data = data ? createFrame(data) : {};\n    data.root = context;\n  }\n  return data;\n}\n},{\"./base\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/base.js\",\"./exception\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/exception.js\",\"./utils\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/utils.js\"}],\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/safe-string.js\":[function(require,module,exports){\n\"use strict\";\n// Build out our basic SafeString type\nfunction SafeString(string) {\n  this.string = string;\n}\n\nSafeString.prototype.toString = function() {\n  return \"\" + this.string;\n};\n\nexports[\"default\"] = SafeString;\n},{}],\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/utils.js\":[function(require,module,exports){\n\"use strict\";\n/*jshint -W004 */\nvar SafeString = require(\"./safe-string\")[\"default\"];\n\nvar escape = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#x27;\",\n  \"`\": \"&#x60;\"\n};\n\nvar badChars = /[&<>\"'`]/g;\nvar possible = /[&<>\"'`]/;\n\nfunction escapeChar(chr) {\n  return escape[chr];\n}\n\nfunction extend(obj /* , ...source */) {\n  for (var i = 1; i < arguments.length; i++) {\n    for (var key in arguments[i]) {\n      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {\n        obj[key] = arguments[i][key];\n      }\n    }\n  }\n\n  return obj;\n}\n\nexports.extend = extend;var toString = Object.prototype.toString;\nexports.toString = toString;\n// Sourced from lodash\n// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt\nvar isFunction = function(value) {\n  return typeof value === 'function';\n};\n// fallback for older versions of Chrome and Safari\n/* istanbul ignore next */\nif (isFunction(/x/)) {\n  isFunction = function(value) {\n    return typeof value === 'function' && toString.call(value) === '[object Function]';\n  };\n}\nvar isFunction;\nexports.isFunction = isFunction;\n/* istanbul ignore next */\nvar isArray = Array.isArray || function(value) {\n  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;\n};\nexports.isArray = isArray;\n\nfunction escapeExpression(string) {\n  // don't escape SafeStrings, since they're already safe\n  if (string instanceof SafeString) {\n    return string.toString();\n  } else if (string == null) {\n    return \"\";\n  } else if (!string) {\n    return string + '';\n  }\n\n  // Force a string conversion as this will be done by the append regardless and\n  // the regex test will do this transparently behind the scenes, causing issues if\n  // an object's to string has escaped characters in it.\n  string = \"\" + string;\n\n  if(!possible.test(string)) { return string; }\n  return string.replace(badChars, escapeChar);\n}\n\nexports.escapeExpression = escapeExpression;function isEmpty(value) {\n  if (!value && value !== 0) {\n    return true;\n  } else if (isArray(value) && value.length === 0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexports.isEmpty = isEmpty;function appendContextPath(contextPath, id) {\n  return (contextPath ? contextPath + '.' : '') + id;\n}\n\nexports.appendContextPath = appendContextPath;\n},{\"./safe-string\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars/safe-string.js\"}],\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/runtime.js\":[function(require,module,exports){\n// Create a simple path alias to allow browserify to resolve\n// the runtime on a supported path.\nmodule.exports = require('./dist/cjs/handlebars.runtime');\n\n},{\"./dist/cjs/handlebars.runtime\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/dist/cjs/handlebars.runtime.js\"}],\"/Users/hoffmeyer/development/ranky/node_modules/hbsfy/runtime.js\":[function(require,module,exports){\nmodule.exports = require(\"handlebars/runtime\")[\"default\"];\n\n},{\"handlebars/runtime\":\"/Users/hoffmeyer/development/ranky/node_modules/handlebars/runtime.js\"}],\"/Users/hoffmeyer/development/ranky/node_modules/observe-js/src/observe.js\":[function(require,module,exports){\n(function (global){\n/*\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n(function(global) {\n  'use strict';\n\n  var testingExposeCycleCount = global.testingExposeCycleCount;\n\n  // Detect and do basic sanity checking on Object/Array.observe.\n  function detectObjectObserve() {\n    if (typeof Object.observe !== 'function' ||\n        typeof Array.observe !== 'function') {\n      return false;\n    }\n\n    var records = [];\n\n    function callback(recs) {\n      records = recs;\n    }\n\n    var test = {};\n    var arr = [];\n    Object.observe(test, callback);\n    Array.observe(arr, callback);\n    test.id = 1;\n    test.id = 2;\n    delete test.id;\n    arr.push(1, 2);\n    arr.length = 0;\n\n    Object.deliverChangeRecords(callback);\n    if (records.length !== 5)\n      return false;\n\n    if (records[0].type != 'add' ||\n        records[1].type != 'update' ||\n        records[2].type != 'delete' ||\n        records[3].type != 'splice' ||\n        records[4].type != 'splice') {\n      return false;\n    }\n\n    Object.unobserve(test, callback);\n    Array.unobserve(arr, callback);\n\n    return true;\n  }\n\n  var hasObserve = detectObjectObserve();\n\n  function detectEval() {\n    // Don't test for eval if we're running in a Chrome App environment.\n    // We check for APIs set that only exist in a Chrome App context.\n    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {\n      return false;\n    }\n\n    // Firefox OS Apps do not allow eval. This feature detection is very hacky\n    // but even if some other platform adds support for this function this code\n    // will continue to work.\n    if (typeof navigator != 'undefined' && navigator.getDeviceStorage) {\n      return false;\n    }\n\n    try {\n      var f = new Function('', 'return true;');\n      return f();\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  var hasEval = detectEval();\n\n  function isIndex(s) {\n    return +s === s >>> 0 && s !== '';\n  }\n\n  function toNumber(s) {\n    return +s;\n  }\n\n  function isObject(obj) {\n    return obj === Object(obj);\n  }\n\n  var numberIsNaN = global.Number.isNaN || function(value) {\n    return typeof value === 'number' && global.isNaN(value);\n  }\n\n  function areSameValue(left, right) {\n    if (left === right)\n      return left !== 0 || 1 / left === 1 / right;\n    if (numberIsNaN(left) && numberIsNaN(right))\n      return true;\n\n    return left !== left && right !== right;\n  }\n\n  var createObject = ('__proto__' in {}) ?\n    function(obj) { return obj; } :\n    function(obj) {\n      var proto = obj.__proto__;\n      if (!proto)\n        return obj;\n      var newObject = Object.create(proto);\n      Object.getOwnPropertyNames(obj).forEach(function(name) {\n        Object.defineProperty(newObject, name,\n                             Object.getOwnPropertyDescriptor(obj, name));\n      });\n      return newObject;\n    };\n\n  var identStart = '[\\$_a-zA-Z]';\n  var identPart = '[\\$_a-zA-Z0-9]';\n  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');\n\n  function getPathCharType(char) {\n    if (char === undefined)\n      return 'eof';\n\n    var code = char.charCodeAt(0);\n\n    switch(code) {\n      case 0x5B: // [\n      case 0x5D: // ]\n      case 0x2E: // .\n      case 0x22: // \"\n      case 0x27: // '\n      case 0x30: // 0\n        return char;\n\n      case 0x5F: // _\n      case 0x24: // $\n        return 'ident';\n\n      case 0x20: // Space\n      case 0x09: // Tab\n      case 0x0A: // Newline\n      case 0x0D: // Return\n      case 0xA0:  // No-break space\n      case 0xFEFF:  // Byte Order Mark\n      case 0x2028:  // Line Separator\n      case 0x2029:  // Paragraph Separator\n        return 'ws';\n    }\n\n    // a-z, A-Z\n    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))\n      return 'ident';\n\n    // 1-9\n    if (0x31 <= code && code <= 0x39)\n      return 'number';\n\n    return 'else';\n  }\n\n  var pathStateMachine = {\n    'beforePath': {\n      'ws': ['beforePath'],\n      'ident': ['inIdent', 'append'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'inPath': {\n      'ws': ['inPath'],\n      '.': ['beforeIdent'],\n      '[': ['beforeElement'],\n      'eof': ['afterPath']\n    },\n\n    'beforeIdent': {\n      'ws': ['beforeIdent'],\n      'ident': ['inIdent', 'append']\n    },\n\n    'inIdent': {\n      'ident': ['inIdent', 'append'],\n      '0': ['inIdent', 'append'],\n      'number': ['inIdent', 'append'],\n      'ws': ['inPath', 'push'],\n      '.': ['beforeIdent', 'push'],\n      '[': ['beforeElement', 'push'],\n      'eof': ['afterPath', 'push']\n    },\n\n    'beforeElement': {\n      'ws': ['beforeElement'],\n      '0': ['afterZero', 'append'],\n      'number': ['inIndex', 'append'],\n      \"'\": ['inSingleQuote', 'append', ''],\n      '\"': ['inDoubleQuote', 'append', '']\n    },\n\n    'afterZero': {\n      'ws': ['afterElement', 'push'],\n      ']': ['inPath', 'push']\n    },\n\n    'inIndex': {\n      '0': ['inIndex', 'append'],\n      'number': ['inIndex', 'append'],\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    },\n\n    'inSingleQuote': {\n      \"'\": ['afterElement'],\n      'eof': ['error'],\n      'else': ['inSingleQuote', 'append']\n    },\n\n    'inDoubleQuote': {\n      '\"': ['afterElement'],\n      'eof': ['error'],\n      'else': ['inDoubleQuote', 'append']\n    },\n\n    'afterElement': {\n      'ws': ['afterElement'],\n      ']': ['inPath', 'push']\n    }\n  }\n\n  function noop() {}\n\n  function parsePath(path) {\n    var keys = [];\n    var index = -1;\n    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';\n\n    var actions = {\n      push: function() {\n        if (key === undefined)\n          return;\n\n        keys.push(key);\n        key = undefined;\n      },\n\n      append: function() {\n        if (key === undefined)\n          key = newChar\n        else\n          key += newChar;\n      }\n    };\n\n    function maybeUnescapeQuote() {\n      if (index >= path.length)\n        return;\n\n      var nextChar = path[index + 1];\n      if ((mode == 'inSingleQuote' && nextChar == \"'\") ||\n          (mode == 'inDoubleQuote' && nextChar == '\"')) {\n        index++;\n        newChar = nextChar;\n        actions.append();\n        return true;\n      }\n    }\n\n    while (mode) {\n      index++;\n      c = path[index];\n\n      if (c == '\\\\' && maybeUnescapeQuote(mode))\n        continue;\n\n      type = getPathCharType(c);\n      typeMap = pathStateMachine[mode];\n      transition = typeMap[type] || typeMap['else'] || 'error';\n\n      if (transition == 'error')\n        return; // parse error;\n\n      mode = transition[0];\n      action = actions[transition[1]] || noop;\n      newChar = transition[2] === undefined ? c : transition[2];\n      action();\n\n      if (mode === 'afterPath') {\n        return keys;\n      }\n    }\n\n    return; // parse error\n  }\n\n  function isIdent(s) {\n    return identRegExp.test(s);\n  }\n\n  var constructorIsPrivate = {};\n\n  function Path(parts, privateToken) {\n    if (privateToken !== constructorIsPrivate)\n      throw Error('Use Path.get to retrieve path objects');\n\n    for (var i = 0; i < parts.length; i++) {\n      this.push(String(parts[i]));\n    }\n\n    if (hasEval && this.length) {\n      this.getValueFrom = this.compiledGetValueFromFn();\n    }\n  }\n\n  // TODO(rafaelw): Make simple LRU cache\n  var pathCache = {};\n\n  function getPath(pathString) {\n    if (pathString instanceof Path)\n      return pathString;\n\n    if (pathString == null || pathString.length == 0)\n      pathString = '';\n\n    if (typeof pathString != 'string') {\n      if (isIndex(pathString.length)) {\n        // Constructed with array-like (pre-parsed) keys\n        return new Path(pathString, constructorIsPrivate);\n      }\n\n      pathString = String(pathString);\n    }\n\n    var path = pathCache[pathString];\n    if (path)\n      return path;\n\n    var parts = parsePath(pathString);\n    if (!parts)\n      return invalidPath;\n\n    var path = new Path(parts, constructorIsPrivate);\n    pathCache[pathString] = path;\n    return path;\n  }\n\n  Path.get = getPath;\n\n  function formatAccessor(key) {\n    if (isIndex(key)) {\n      return '[' + key + ']';\n    } else {\n      return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]';\n    }\n  }\n\n  Path.prototype = createObject({\n    __proto__: [],\n    valid: true,\n\n    toString: function() {\n      var pathString = '';\n      for (var i = 0; i < this.length; i++) {\n        var key = this[i];\n        if (isIdent(key)) {\n          pathString += i ? '.' + key : key;\n        } else {\n          pathString += formatAccessor(key);\n        }\n      }\n\n      return pathString;\n    },\n\n    getValueFrom: function(obj, directObserver) {\n      for (var i = 0; i < this.length; i++) {\n        if (obj == null)\n          return;\n        obj = obj[this[i]];\n      }\n      return obj;\n    },\n\n    iterateObjects: function(obj, observe) {\n      for (var i = 0; i < this.length; i++) {\n        if (i)\n          obj = obj[this[i - 1]];\n        if (!isObject(obj))\n          return;\n        observe(obj, this[i]);\n      }\n    },\n\n    compiledGetValueFromFn: function() {\n      var str = '';\n      var pathString = 'obj';\n      str += 'if (obj != null';\n      var i = 0;\n      var key;\n      for (; i < (this.length - 1); i++) {\n        key = this[i];\n        pathString += isIdent(key) ? '.' + key : formatAccessor(key);\n        str += ' &&\\n     ' + pathString + ' != null';\n      }\n      str += ')\\n';\n\n      var key = this[i];\n      pathString += isIdent(key) ? '.' + key : formatAccessor(key);\n\n      str += '  return ' + pathString + ';\\nelse\\n  return undefined;';\n      return new Function('obj', str);\n    },\n\n    setValueFrom: function(obj, value) {\n      if (!this.length)\n        return false;\n\n      for (var i = 0; i < this.length - 1; i++) {\n        if (!isObject(obj))\n          return false;\n        obj = obj[this[i]];\n      }\n\n      if (!isObject(obj))\n        return false;\n\n      obj[this[i]] = value;\n      return true;\n    }\n  });\n\n  var invalidPath = new Path('', constructorIsPrivate);\n  invalidPath.valid = false;\n  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};\n\n  var MAX_DIRTY_CHECK_CYCLES = 1000;\n\n  function dirtyCheck(observer) {\n    var cycles = 0;\n    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {\n      cycles++;\n    }\n    if (testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    return cycles > 0;\n  }\n\n  function objectIsEmpty(object) {\n    for (var prop in object)\n      return false;\n    return true;\n  }\n\n  function diffIsEmpty(diff) {\n    return objectIsEmpty(diff.added) &&\n           objectIsEmpty(diff.removed) &&\n           objectIsEmpty(diff.changed);\n  }\n\n  function diffObjectFromOldObject(object, oldObject) {\n    var added = {};\n    var removed = {};\n    var changed = {};\n\n    for (var prop in oldObject) {\n      var newValue = object[prop];\n\n      if (newValue !== undefined && newValue === oldObject[prop])\n        continue;\n\n      if (!(prop in object)) {\n        removed[prop] = undefined;\n        continue;\n      }\n\n      if (newValue !== oldObject[prop])\n        changed[prop] = newValue;\n    }\n\n    for (var prop in object) {\n      if (prop in oldObject)\n        continue;\n\n      added[prop] = object[prop];\n    }\n\n    if (Array.isArray(object) && object.length !== oldObject.length)\n      changed.length = object.length;\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  var eomTasks = [];\n  function runEOMTasks() {\n    if (!eomTasks.length)\n      return false;\n\n    for (var i = 0; i < eomTasks.length; i++) {\n      eomTasks[i]();\n    }\n    eomTasks.length = 0;\n    return true;\n  }\n\n  var runEOM = hasObserve ? (function(){\n    return function(fn) {\n      return Promise.resolve().then(fn);\n    }\n  })() :\n  (function() {\n    return function(fn) {\n      eomTasks.push(fn);\n    };\n  })();\n\n  var observedObjectCache = [];\n\n  function newObservedObject() {\n    var observer;\n    var object;\n    var discardRecords = false;\n    var first = true;\n\n    function callback(records) {\n      if (observer && observer.state_ === OPENED && !discardRecords)\n        observer.check_(records);\n    }\n\n    return {\n      open: function(obs) {\n        if (observer)\n          throw Error('ObservedObject in use');\n\n        if (!first)\n          Object.deliverChangeRecords(callback);\n\n        observer = obs;\n        first = false;\n      },\n      observe: function(obj, arrayObserve) {\n        object = obj;\n        if (arrayObserve)\n          Array.observe(object, callback);\n        else\n          Object.observe(object, callback);\n      },\n      deliver: function(discard) {\n        discardRecords = discard;\n        Object.deliverChangeRecords(callback);\n        discardRecords = false;\n      },\n      close: function() {\n        observer = undefined;\n        Object.unobserve(object, callback);\n        observedObjectCache.push(this);\n      }\n    };\n  }\n\n  /*\n   * The observedSet abstraction is a perf optimization which reduces the total\n   * number of Object.observe observations of a set of objects. The idea is that\n   * groups of Observers will have some object dependencies in common and this\n   * observed set ensures that each object in the transitive closure of\n   * dependencies is only observed once. The observedSet acts as a write barrier\n   * such that whenever any change comes through, all Observers are checked for\n   * changed values.\n   *\n   * Note that this optimization is explicitly moving work from setup-time to\n   * change-time.\n   *\n   * TODO(rafaelw): Implement \"garbage collection\". In order to move work off\n   * the critical path, when Observers are closed, their observed objects are\n   * not Object.unobserve(d). As a result, it's possible that if the observedSet\n   * is kept open, but some Observers have been closed, it could cause \"leaks\"\n   * (prevent otherwise collectable objects from being collected). At some\n   * point, we should implement incremental \"gc\" which keeps a list of\n   * observedSets which may need clean-up and does small amounts of cleanup on a\n   * timeout until all is clean.\n   */\n\n  function getObservedObject(observer, object, arrayObserve) {\n    var dir = observedObjectCache.pop() || newObservedObject();\n    dir.open(observer);\n    dir.observe(object, arrayObserve);\n    return dir;\n  }\n\n  var observedSetCache = [];\n\n  function newObservedSet() {\n    var observerCount = 0;\n    var observers = [];\n    var objects = [];\n    var rootObj;\n    var rootObjProps;\n\n    function observe(obj, prop) {\n      if (!obj)\n        return;\n\n      if (obj === rootObj)\n        rootObjProps[prop] = true;\n\n      if (objects.indexOf(obj) < 0) {\n        objects.push(obj);\n        Object.observe(obj, callback);\n      }\n\n      observe(Object.getPrototypeOf(obj), prop);\n    }\n\n    function allRootObjNonObservedProps(recs) {\n      for (var i = 0; i < recs.length; i++) {\n        var rec = recs[i];\n        if (rec.object !== rootObj ||\n            rootObjProps[rec.name] ||\n            rec.type === 'setPrototype') {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    function callback(recs) {\n      if (allRootObjNonObservedProps(recs))\n        return;\n\n      var observer;\n      for (var i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.iterateObjects_(observe);\n        }\n      }\n\n      for (var i = 0; i < observers.length; i++) {\n        observer = observers[i];\n        if (observer.state_ == OPENED) {\n          observer.check_();\n        }\n      }\n    }\n\n    var record = {\n      objects: objects,\n      get rootObject() { return rootObj; },\n      set rootObject(value) {\n        rootObj = value;\n        rootObjProps = {};\n      },\n      open: function(obs, object) {\n        observers.push(obs);\n        observerCount++;\n        obs.iterateObjects_(observe);\n      },\n      close: function(obs) {\n        observerCount--;\n        if (observerCount > 0) {\n          return;\n        }\n\n        for (var i = 0; i < objects.length; i++) {\n          Object.unobserve(objects[i], callback);\n          Observer.unobservedCount++;\n        }\n\n        observers.length = 0;\n        objects.length = 0;\n        rootObj = undefined;\n        rootObjProps = undefined;\n        observedSetCache.push(this);\n        if (lastObservedSet === this)\n          lastObservedSet = null;\n      },\n    };\n\n    return record;\n  }\n\n  var lastObservedSet;\n\n  function getObservedSet(observer, obj) {\n    if (!lastObservedSet || lastObservedSet.rootObject !== obj) {\n      lastObservedSet = observedSetCache.pop() || newObservedSet();\n      lastObservedSet.rootObject = obj;\n    }\n    lastObservedSet.open(observer, obj);\n    return lastObservedSet;\n  }\n\n  var UNOPENED = 0;\n  var OPENED = 1;\n  var CLOSED = 2;\n  var RESETTING = 3;\n\n  var nextObserverId = 1;\n\n  function Observer() {\n    this.state_ = UNOPENED;\n    this.callback_ = undefined;\n    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef\n    this.directObserver_ = undefined;\n    this.value_ = undefined;\n    this.id_ = nextObserverId++;\n  }\n\n  Observer.prototype = {\n    open: function(callback, target) {\n      if (this.state_ != UNOPENED)\n        throw Error('Observer has already been opened.');\n\n      addToAll(this);\n      this.callback_ = callback;\n      this.target_ = target;\n      this.connect_();\n      this.state_ = OPENED;\n      return this.value_;\n    },\n\n    close: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      removeFromAll(this);\n      this.disconnect_();\n      this.value_ = undefined;\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.state_ = CLOSED;\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      dirtyCheck(this);\n    },\n\n    report_: function(changes) {\n      try {\n        this.callback_.apply(this.target_, changes);\n      } catch (ex) {\n        Observer._errorThrownDuringCallback = true;\n        console.error('Exception caught during observer callback: ' +\n                       (ex.stack || ex));\n      }\n    },\n\n    discardChanges: function() {\n      this.check_(undefined, true);\n      return this.value_;\n    }\n  }\n\n  var collectObservers = !hasObserve;\n  var allObservers;\n  Observer._allObserversCount = 0;\n\n  if (collectObservers) {\n    allObservers = [];\n  }\n\n  function addToAll(observer) {\n    Observer._allObserversCount++;\n    if (!collectObservers)\n      return;\n\n    allObservers.push(observer);\n  }\n\n  function removeFromAll(observer) {\n    Observer._allObserversCount--;\n  }\n\n  var runningMicrotaskCheckpoint = false;\n\n  global.Platform = global.Platform || {};\n\n  global.Platform.performMicrotaskCheckpoint = function() {\n    if (runningMicrotaskCheckpoint)\n      return;\n\n    if (!collectObservers)\n      return;\n\n    runningMicrotaskCheckpoint = true;\n\n    var cycles = 0;\n    var anyChanged, toCheck;\n\n    do {\n      cycles++;\n      toCheck = allObservers;\n      allObservers = [];\n      anyChanged = false;\n\n      for (var i = 0; i < toCheck.length; i++) {\n        var observer = toCheck[i];\n        if (observer.state_ != OPENED)\n          continue;\n\n        if (observer.check_())\n          anyChanged = true;\n\n        allObservers.push(observer);\n      }\n      if (runEOMTasks())\n        anyChanged = true;\n    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);\n\n    if (testingExposeCycleCount)\n      global.dirtyCheckCycleCount = cycles;\n\n    runningMicrotaskCheckpoint = false;\n  };\n\n  if (collectObservers) {\n    global.Platform.clearObservers = function() {\n      allObservers = [];\n    };\n  }\n\n  function ObjectObserver(object) {\n    Observer.call(this);\n    this.value_ = object;\n    this.oldObject_ = undefined;\n  }\n\n  ObjectObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    arrayObserve: false,\n\n    connect_: function(callback, target) {\n      if (hasObserve) {\n        this.directObserver_ = getObservedObject(this, this.value_,\n                                                 this.arrayObserve);\n      } else {\n        this.oldObject_ = this.copyObject(this.value_);\n      }\n\n    },\n\n    copyObject: function(object) {\n      var copy = Array.isArray(object) ? [] : {};\n      for (var prop in object) {\n        copy[prop] = object[prop];\n      };\n      if (Array.isArray(object))\n        copy.length = object.length;\n      return copy;\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var diff;\n      var oldValues;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n\n        oldValues = {};\n        diff = diffObjectFromChangeRecords(this.value_, changeRecords,\n                                           oldValues);\n      } else {\n        oldValues = this.oldObject_;\n        diff = diffObjectFromOldObject(this.value_, this.oldObject_);\n      }\n\n      if (diffIsEmpty(diff))\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([\n        diff.added || {},\n        diff.removed || {},\n        diff.changed || {},\n        function(property) {\n          return oldValues[property];\n        }\n      ]);\n\n      return true;\n    },\n\n    disconnect_: function() {\n      if (hasObserve) {\n        this.directObserver_.close();\n        this.directObserver_ = undefined;\n      } else {\n        this.oldObject_ = undefined;\n      }\n    },\n\n    deliver: function() {\n      if (this.state_ != OPENED)\n        return;\n\n      if (hasObserve)\n        this.directObserver_.deliver(false);\n      else\n        dirtyCheck(this);\n    },\n\n    discardChanges: function() {\n      if (this.directObserver_)\n        this.directObserver_.deliver(true);\n      else\n        this.oldObject_ = this.copyObject(this.value_);\n\n      return this.value_;\n    }\n  });\n\n  function ArrayObserver(array) {\n    if (!Array.isArray(array))\n      throw Error('Provided object is not an Array');\n    ObjectObserver.call(this, array);\n  }\n\n  ArrayObserver.prototype = createObject({\n\n    __proto__: ObjectObserver.prototype,\n\n    arrayObserve: true,\n\n    copyObject: function(arr) {\n      return arr.slice();\n    },\n\n    check_: function(changeRecords) {\n      var splices;\n      if (hasObserve) {\n        if (!changeRecords)\n          return false;\n        splices = projectArraySplices(this.value_, changeRecords);\n      } else {\n        splices = calcSplices(this.value_, 0, this.value_.length,\n                              this.oldObject_, 0, this.oldObject_.length);\n      }\n\n      if (!splices || !splices.length)\n        return false;\n\n      if (!hasObserve)\n        this.oldObject_ = this.copyObject(this.value_);\n\n      this.report_([splices]);\n      return true;\n    }\n  });\n\n  ArrayObserver.applySplices = function(previous, current, splices) {\n    splices.forEach(function(splice) {\n      var spliceArgs = [splice.index, splice.removed.length];\n      var addIndex = splice.index;\n      while (addIndex < splice.index + splice.addedCount) {\n        spliceArgs.push(current[addIndex]);\n        addIndex++;\n      }\n\n      Array.prototype.splice.apply(previous, spliceArgs);\n    });\n  };\n\n  function PathObserver(object, path) {\n    Observer.call(this);\n\n    this.object_ = object;\n    this.path_ = getPath(path);\n    this.directObserver_ = undefined;\n  }\n\n  PathObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    get path() {\n      return this.path_;\n    },\n\n    connect_: function() {\n      if (hasObserve)\n        this.directObserver_ = getObservedSet(this, this.object_);\n\n      this.check_(undefined, true);\n    },\n\n    disconnect_: function() {\n      this.value_ = undefined;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    iterateObjects_: function(observe) {\n      this.path_.iterateObjects(this.object_, observe);\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValue = this.value_;\n      this.value_ = this.path_.getValueFrom(this.object_);\n      if (skipChanges || areSameValue(this.value_, oldValue))\n        return false;\n\n      this.report_([this.value_, oldValue, this]);\n      return true;\n    },\n\n    setValue: function(newValue) {\n      if (this.path_)\n        this.path_.setValueFrom(this.object_, newValue);\n    }\n  });\n\n  function CompoundObserver(reportChangesOnOpen) {\n    Observer.call(this);\n\n    this.reportChangesOnOpen_ = reportChangesOnOpen;\n    this.value_ = [];\n    this.directObserver_ = undefined;\n    this.observed_ = [];\n  }\n\n  var observerSentinel = {};\n\n  CompoundObserver.prototype = createObject({\n    __proto__: Observer.prototype,\n\n    connect_: function() {\n      if (hasObserve) {\n        var object;\n        var needsDirectObserver = false;\n        for (var i = 0; i < this.observed_.length; i += 2) {\n          object = this.observed_[i]\n          if (object !== observerSentinel) {\n            needsDirectObserver = true;\n            break;\n          }\n        }\n\n        if (needsDirectObserver)\n          this.directObserver_ = getObservedSet(this, object);\n      }\n\n      this.check_(undefined, !this.reportChangesOnOpen_);\n    },\n\n    disconnect_: function() {\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        if (this.observed_[i] === observerSentinel)\n          this.observed_[i + 1].close();\n      }\n      this.observed_.length = 0;\n      this.value_.length = 0;\n\n      if (this.directObserver_) {\n        this.directObserver_.close(this);\n        this.directObserver_ = undefined;\n      }\n    },\n\n    addPath: function(object, path) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add paths once started.');\n\n      var path = getPath(path);\n      this.observed_.push(object, path);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = path.getValueFrom(object);\n    },\n\n    addObserver: function(observer) {\n      if (this.state_ != UNOPENED && this.state_ != RESETTING)\n        throw Error('Cannot add observers once started.');\n\n      this.observed_.push(observerSentinel, observer);\n      if (!this.reportChangesOnOpen_)\n        return;\n      var index = this.observed_.length / 2 - 1;\n      this.value_[index] = observer.open(this.deliver, this);\n    },\n\n    startReset: function() {\n      if (this.state_ != OPENED)\n        throw Error('Can only reset while open');\n\n      this.state_ = RESETTING;\n      this.disconnect_();\n    },\n\n    finishReset: function() {\n      if (this.state_ != RESETTING)\n        throw Error('Can only finishReset after startReset');\n      this.state_ = OPENED;\n      this.connect_();\n\n      return this.value_;\n    },\n\n    iterateObjects_: function(observe) {\n      var object;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        object = this.observed_[i]\n        if (object !== observerSentinel)\n          this.observed_[i + 1].iterateObjects(object, observe)\n      }\n    },\n\n    check_: function(changeRecords, skipChanges) {\n      var oldValues;\n      for (var i = 0; i < this.observed_.length; i += 2) {\n        var object = this.observed_[i];\n        var path = this.observed_[i+1];\n        var value;\n        if (object === observerSentinel) {\n          var observable = path;\n          value = this.state_ === UNOPENED ?\n              observable.open(this.deliver, this) :\n              observable.discardChanges();\n        } else {\n          value = path.getValueFrom(object);\n        }\n\n        if (skipChanges) {\n          this.value_[i / 2] = value;\n          continue;\n        }\n\n        if (areSameValue(value, this.value_[i / 2]))\n          continue;\n\n        oldValues = oldValues || [];\n        oldValues[i / 2] = this.value_[i / 2];\n        this.value_[i / 2] = value;\n      }\n\n      if (!oldValues)\n        return false;\n\n      // TODO(rafaelw): Having observed_ as the third callback arg here is\n      // pretty lame API. Fix.\n      this.report_([this.value_, oldValues, this.observed_]);\n      return true;\n    }\n  });\n\n  function identFn(value) { return value; }\n\n  function ObserverTransform(observable, getValueFn, setValueFn,\n                             dontPassThroughSet) {\n    this.callback_ = undefined;\n    this.target_ = undefined;\n    this.value_ = undefined;\n    this.observable_ = observable;\n    this.getValueFn_ = getValueFn || identFn;\n    this.setValueFn_ = setValueFn || identFn;\n    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this\n    // at the moment because of a bug in it's dependency tracking.\n    this.dontPassThroughSet_ = dontPassThroughSet;\n  }\n\n  ObserverTransform.prototype = {\n    open: function(callback, target) {\n      this.callback_ = callback;\n      this.target_ = target;\n      this.value_ =\n          this.getValueFn_(this.observable_.open(this.observedCallback_, this));\n      return this.value_;\n    },\n\n    observedCallback_: function(value) {\n      value = this.getValueFn_(value);\n      if (areSameValue(value, this.value_))\n        return;\n      var oldValue = this.value_;\n      this.value_ = value;\n      this.callback_.call(this.target_, this.value_, oldValue);\n    },\n\n    discardChanges: function() {\n      this.value_ = this.getValueFn_(this.observable_.discardChanges());\n      return this.value_;\n    },\n\n    deliver: function() {\n      return this.observable_.deliver();\n    },\n\n    setValue: function(value) {\n      value = this.setValueFn_(value);\n      if (!this.dontPassThroughSet_ && this.observable_.setValue)\n        return this.observable_.setValue(value);\n    },\n\n    close: function() {\n      if (this.observable_)\n        this.observable_.close();\n      this.callback_ = undefined;\n      this.target_ = undefined;\n      this.observable_ = undefined;\n      this.value_ = undefined;\n      this.getValueFn_ = undefined;\n      this.setValueFn_ = undefined;\n    }\n  }\n\n  var expectedRecordTypes = {\n    add: true,\n    update: true,\n    delete: true\n  };\n\n  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {\n    var added = {};\n    var removed = {};\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      if (!expectedRecordTypes[record.type]) {\n        console.error('Unknown changeRecord type: ' + record.type);\n        console.error(record);\n        continue;\n      }\n\n      if (!(record.name in oldValues))\n        oldValues[record.name] = record.oldValue;\n\n      if (record.type == 'update')\n        continue;\n\n      if (record.type == 'add') {\n        if (record.name in removed)\n          delete removed[record.name];\n        else\n          added[record.name] = true;\n\n        continue;\n      }\n\n      // type = 'delete'\n      if (record.name in added) {\n        delete added[record.name];\n        delete oldValues[record.name];\n      } else {\n        removed[record.name] = true;\n      }\n    }\n\n    for (var prop in added)\n      added[prop] = object[prop];\n\n    for (var prop in removed)\n      removed[prop] = undefined;\n\n    var changed = {};\n    for (var prop in oldValues) {\n      if (prop in added || prop in removed)\n        continue;\n\n      var newValue = object[prop];\n      if (oldValues[prop] !== newValue)\n        changed[prop] = newValue;\n    }\n\n    return {\n      added: added,\n      removed: removed,\n      changed: changed\n    };\n  }\n\n  function newSplice(index, removed, addedCount) {\n    return {\n      index: index,\n      removed: removed,\n      addedCount: addedCount\n    };\n  }\n\n  var EDIT_LEAVE = 0;\n  var EDIT_UPDATE = 1;\n  var EDIT_ADD = 2;\n  var EDIT_DELETE = 3;\n\n  function ArraySplice() {}\n\n  ArraySplice.prototype = {\n\n    // Note: This function is *based* on the computation of the Levenshtein\n    // \"edit\" distance. The one change is that \"updates\" are treated as two\n    // edits - not one. With Array splices, an update is really a delete\n    // followed by an add. By retaining this, we optimize for \"keeping\" the\n    // maximum array items in the original array. For example:\n    //\n    //   'xxxx123' -> '123yyyy'\n    //\n    // With 1-edit updates, the shortest path would be just to update all seven\n    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n    // leaves the substring '123' intact.\n    calcEditDistances: function(current, currentStart, currentEnd,\n                                old, oldStart, oldEnd) {\n      // \"Deletion\" columns\n      var rowCount = oldEnd - oldStart + 1;\n      var columnCount = currentEnd - currentStart + 1;\n      var distances = new Array(rowCount);\n\n      // \"Addition\" rows. Initialize null column.\n      for (var i = 0; i < rowCount; i++) {\n        distances[i] = new Array(columnCount);\n        distances[i][0] = i;\n      }\n\n      // Initialize null row\n      for (var j = 0; j < columnCount; j++)\n        distances[0][j] = j;\n\n      for (var i = 1; i < rowCount; i++) {\n        for (var j = 1; j < columnCount; j++) {\n          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\n            distances[i][j] = distances[i - 1][j - 1];\n          else {\n            var north = distances[i - 1][j] + 1;\n            var west = distances[i][j - 1] + 1;\n            distances[i][j] = north < west ? north : west;\n          }\n        }\n      }\n\n      return distances;\n    },\n\n    // This starts at the final weight, and walks \"backward\" by finding\n    // the minimum previous weight recursively until the origin of the weight\n    // matrix.\n    spliceOperationsFromEditDistances: function(distances) {\n      var i = distances.length - 1;\n      var j = distances[0].length - 1;\n      var current = distances[i][j];\n      var edits = [];\n      while (i > 0 || j > 0) {\n        if (i == 0) {\n          edits.push(EDIT_ADD);\n          j--;\n          continue;\n        }\n        if (j == 0) {\n          edits.push(EDIT_DELETE);\n          i--;\n          continue;\n        }\n        var northWest = distances[i - 1][j - 1];\n        var west = distances[i - 1][j];\n        var north = distances[i][j - 1];\n\n        var min;\n        if (west < north)\n          min = west < northWest ? west : northWest;\n        else\n          min = north < northWest ? north : northWest;\n\n        if (min == northWest) {\n          if (northWest == current) {\n            edits.push(EDIT_LEAVE);\n          } else {\n            edits.push(EDIT_UPDATE);\n            current = northWest;\n          }\n          i--;\n          j--;\n        } else if (min == west) {\n          edits.push(EDIT_DELETE);\n          i--;\n          current = west;\n        } else {\n          edits.push(EDIT_ADD);\n          j--;\n          current = north;\n        }\n      }\n\n      edits.reverse();\n      return edits;\n    },\n\n    /**\n     * Splice Projection functions:\n     *\n     * A splice map is a representation of how a previous array of items\n     * was transformed into a new array of items. Conceptually it is a list of\n     * tuples of\n     *\n     *   <index, removed, addedCount>\n     *\n     * which are kept in ascending index order of. The tuple represents that at\n     * the |index|, |removed| sequence of items were removed, and counting forward\n     * from |index|, |addedCount| items were added.\n     */\n\n    /**\n     * Lacking individual splice mutation information, the minimal set of\n     * splices can be synthesized given the previous state and final state of an\n     * array. The basic approach is to calculate the edit distance matrix and\n     * choose the shortest path through it.\n     *\n     * Complexity: O(l * p)\n     *   l: The length of the current array\n     *   p: The length of the old array\n     */\n    calcSplices: function(current, currentStart, currentEnd,\n                          old, oldStart, oldEnd) {\n      var prefixCount = 0;\n      var suffixCount = 0;\n\n      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n      if (currentStart == 0 && oldStart == 0)\n        prefixCount = this.sharedPrefix(current, old, minLength);\n\n      if (currentEnd == current.length && oldEnd == old.length)\n        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\n      currentStart += prefixCount;\n      oldStart += prefixCount;\n      currentEnd -= suffixCount;\n      oldEnd -= suffixCount;\n\n      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n        return [];\n\n      if (currentStart == currentEnd) {\n        var splice = newSplice(currentStart, [], 0);\n        while (oldStart < oldEnd)\n          splice.removed.push(old[oldStart++]);\n\n        return [ splice ];\n      } else if (oldStart == oldEnd)\n        return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n      var ops = this.spliceOperationsFromEditDistances(\n          this.calcEditDistances(current, currentStart, currentEnd,\n                                 old, oldStart, oldEnd));\n\n      var splice = undefined;\n      var splices = [];\n      var index = currentStart;\n      var oldIndex = oldStart;\n      for (var i = 0; i < ops.length; i++) {\n        switch(ops[i]) {\n          case EDIT_LEAVE:\n            if (splice) {\n              splices.push(splice);\n              splice = undefined;\n            }\n\n            index++;\n            oldIndex++;\n            break;\n          case EDIT_UPDATE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n          case EDIT_ADD:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.addedCount++;\n            index++;\n            break;\n          case EDIT_DELETE:\n            if (!splice)\n              splice = newSplice(index, [], 0);\n\n            splice.removed.push(old[oldIndex]);\n            oldIndex++;\n            break;\n        }\n      }\n\n      if (splice) {\n        splices.push(splice);\n      }\n      return splices;\n    },\n\n    sharedPrefix: function(current, old, searchLength) {\n      for (var i = 0; i < searchLength; i++)\n        if (!this.equals(current[i], old[i]))\n          return i;\n      return searchLength;\n    },\n\n    sharedSuffix: function(current, old, searchLength) {\n      var index1 = current.length;\n      var index2 = old.length;\n      var count = 0;\n      while (count < searchLength && this.equals(current[--index1], old[--index2]))\n        count++;\n\n      return count;\n    },\n\n    calculateSplices: function(current, previous) {\n      return this.calcSplices(current, 0, current.length, previous, 0,\n                              previous.length);\n    },\n\n    equals: function(currentValue, previousValue) {\n      return currentValue === previousValue;\n    }\n  };\n\n  var arraySplice = new ArraySplice();\n\n  function calcSplices(current, currentStart, currentEnd,\n                       old, oldStart, oldEnd) {\n    return arraySplice.calcSplices(current, currentStart, currentEnd,\n                                   old, oldStart, oldEnd);\n  }\n\n  function intersect(start1, end1, start2, end2) {\n    // Disjoint\n    if (end1 < start2 || end2 < start1)\n      return -1;\n\n    // Adjacent\n    if (end1 == start2 || end2 == start1)\n      return 0;\n\n    // Non-zero intersect, span1 first\n    if (start1 < start2) {\n      if (end1 < end2)\n        return end1 - start2; // Overlap\n      else\n        return end2 - start2; // Contained\n    } else {\n      // Non-zero intersect, span2 first\n      if (end2 < end1)\n        return end2 - start1; // Overlap\n      else\n        return end1 - start1; // Contained\n    }\n  }\n\n  function mergeSplice(splices, index, removed, addedCount) {\n\n    var splice = newSplice(index, removed, addedCount);\n\n    var inserted = false;\n    var insertionOffset = 0;\n\n    for (var i = 0; i < splices.length; i++) {\n      var current = splices[i];\n      current.index += insertionOffset;\n\n      if (inserted)\n        continue;\n\n      var intersectCount = intersect(splice.index,\n                                     splice.index + splice.removed.length,\n                                     current.index,\n                                     current.index + current.addedCount);\n\n      if (intersectCount >= 0) {\n        // Merge the two splices\n\n        splices.splice(i, 1);\n        i--;\n\n        insertionOffset -= current.addedCount - current.removed.length;\n\n        splice.addedCount += current.addedCount - intersectCount;\n        var deleteCount = splice.removed.length +\n                          current.removed.length - intersectCount;\n\n        if (!splice.addedCount && !deleteCount) {\n          // merged splice is a noop. discard.\n          inserted = true;\n        } else {\n          var removed = current.removed;\n\n          if (splice.index < current.index) {\n            // some prefix of splice.removed is prepended to current.removed.\n            var prepend = splice.removed.slice(0, current.index - splice.index);\n            Array.prototype.push.apply(prepend, removed);\n            removed = prepend;\n          }\n\n          if (splice.index + splice.removed.length > current.index + current.addedCount) {\n            // some suffix of splice.removed is appended to current.removed.\n            var append = splice.removed.slice(current.index + current.addedCount - splice.index);\n            Array.prototype.push.apply(removed, append);\n          }\n\n          splice.removed = removed;\n          if (current.index < splice.index) {\n            splice.index = current.index;\n          }\n        }\n      } else if (splice.index < current.index) {\n        // Insert splice here.\n\n        inserted = true;\n\n        splices.splice(i, 0, splice);\n        i++;\n\n        var offset = splice.addedCount - splice.removed.length\n        current.index += offset;\n        insertionOffset += offset;\n      }\n    }\n\n    if (!inserted)\n      splices.push(splice);\n  }\n\n  function createInitialSplices(array, changeRecords) {\n    var splices = [];\n\n    for (var i = 0; i < changeRecords.length; i++) {\n      var record = changeRecords[i];\n      switch(record.type) {\n        case 'splice':\n          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);\n          break;\n        case 'add':\n        case 'update':\n        case 'delete':\n          if (!isIndex(record.name))\n            continue;\n          var index = toNumber(record.name);\n          if (index < 0)\n            continue;\n          mergeSplice(splices, index, [record.oldValue], 1);\n          break;\n        default:\n          console.error('Unexpected record type: ' + JSON.stringify(record));\n          break;\n      }\n    }\n\n    return splices;\n  }\n\n  function projectArraySplices(array, changeRecords) {\n    var splices = [];\n\n    createInitialSplices(array, changeRecords).forEach(function(splice) {\n      if (splice.addedCount == 1 && splice.removed.length == 1) {\n        if (splice.removed[0] !== array[splice.index])\n          splices.push(splice);\n\n        return\n      };\n\n      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,\n                                           splice.removed, 0, splice.removed.length));\n    });\n\n    return splices;\n  }\n\n  // Export the observe-js object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, export as a global object.\n\n  var expose = global;\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      expose = exports = module.exports;\n    }\n    expose = exports;\n  } \n\n  expose.Observer = Observer;\n  expose.Observer.runEOM_ = runEOM;\n  expose.Observer.observerSentinel_ = observerSentinel; // for testing.\n  expose.Observer.hasObjectObserve = hasObserve;\n  expose.ArrayObserver = ArrayObserver;\n  expose.ArrayObserver.calculateSplices = function(current, previous) {\n    return arraySplice.calculateSplices(current, previous);\n  };\n\n  expose.ArraySplice = ArraySplice;\n  expose.ObjectObserver = ObjectObserver;\n  expose.PathObserver = PathObserver;\n  expose.CompoundObserver = CompoundObserver;\n  expose.Path = Path;\n  expose.ObserverTransform = ObserverTransform;\n  \n})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],\"/Users/hoffmeyer/development/ranky/tpl/newMatch.hbs\":[function(require,module,exports){\n// hbsfy compiled Handlebars template\nvar HandlebarsCompiler = require('hbsfy/runtime');\nmodule.exports = HandlebarsCompiler.template({\"compiler\":[6,\">= 2.0.0-beta.1\"],\"main\":function(depth0,helpers,partials,data) {\n  return \"<div class='addMatch'>\\n    <form class=\\\"form-horizontal\\\">\\n        <div class=\\\"form-group\\\">\\n            <label class=\\\"col-sm-2 control-label\\\" for=\\\"newMatch-team1-player1\\\">Team 1</label>\\n            <div class=\\\"col-sm-4\\\">\\n                <input id=\\\"newMatch-team1-player1\\\" class=\\\"form-control\\\" placeholder=\\\"Player 1\\\"></input>\\n            </div>\\n            <div class=\\\"col-sm-4\\\">\\n                <input id=\\\"newMatch-team1-player2\\\" class=\\\"form-control\\\" placeholder=\\\"Player 2\\\"></input>\\n            </div>\\n            <div class=\\\"col-sm-2\\\">\\n                <input id=\\\"newMatch-team1-score\\\" class=\\\"form-control\\\" placeholder=\\\"Score\\\"></input>\\n            </div>\\n        </div>\\n        <div class=\\\"form-group\\\">\\n            <label class=\\\"col-sm-2 control-label\\\" for=\\\"newMatch-team2-player1\\\">Team 2</label>\\n            <div class=\\\"col-sm-4\\\">\\n                <input id=\\\"newMatch-team2-player1\\\" class=\\\"form-control\\\" placeholder=\\\"Player 1\\\"></input>\\n            </div>\\n            <div class=\\\"col-sm-4\\\">\\n                <input id=\\\"newMatch-team2-player2\\\" class=\\\"form-control\\\" placeholder=\\\"Player 2\\\"></input>\\n            </div>\\n            <div class=\\\"col-sm-2\\\">\\n                <input id=\\\"newMatch-team2-score\\\" class=\\\"form-control\\\" placeholder=\\\"Score\\\"></input>\\n            </div>\\n        </div>\\n        <div class=\\\"form-group\\\">\\n            <div class=\\\"col-sm-offset-2 col-sm-10\\\">\\n                <button id=\\\"newMatch-btn\\\" type=\\\"submit\\\" class=\\\"btn btn-primary pull-right\\\">Register match</button>\\n            </div>\\n        </div>\\n    </form>\\n</div>\\n\";\n  },\"useData\":true});\n\n},{\"hbsfy/runtime\":\"/Users/hoffmeyer/development/ranky/node_modules/hbsfy/runtime.js\"}],\"/Users/hoffmeyer/development/ranky/tpl/playerList.hbs\":[function(require,module,exports){\n// hbsfy compiled Handlebars template\nvar HandlebarsCompiler = require('hbsfy/runtime');\nmodule.exports = HandlebarsCompiler.template({\"1\":function(depth0,helpers,partials,data) {\n  var helper, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType=\"function\";\n  return \"    <tr class=\\\"PlayerList-item\\\">\\n      <td class=\\\"PlayerList-item-place\\\">\"\n    + escapeExpression(((helpers.inc || (depth0 && depth0.inc) || helperMissing).call(depth0, (data && data.index), {\"name\":\"inc\",\"hash\":{},\"data\":data})))\n    + \"</td>\\n      <td class=\\\"PlayerList-item-name\\\">\"\n    + escapeExpression(((helper = (helper = helpers.name || (depth0 != null ? depth0.name : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {\"name\":\"name\",\"hash\":{},\"data\":data}) : helper)))\n    + \"</td>\\n      <td class=\\\"PlayerList-item-points\\\">\"\n    + escapeExpression(((helper = (helper = helpers.points || (depth0 != null ? depth0.points : depth0)) != null ? helper : helperMissing),(typeof helper === functionType ? helper.call(depth0, {\"name\":\"points\",\"hash\":{},\"data\":data}) : helper)))\n    + \"</td>\\n    </tr>\\n\";\n},\"compiler\":[6,\">= 2.0.0-beta.1\"],\"main\":function(depth0,helpers,partials,data) {\n  var stack1, buffer = \"<div class=\\\"playerList\\\">\\n  <table class=\\\"table\\\">\\n    <tr class=\\\"PlayerList-item\\\">\\n      <th class=\\\"PlayerList-item-place\\\">#</th>\\n      <th class=\\\"PlayerList-item-name\\\">Player name</th>\\n      <th class=\\\"PlayerList-item-points\\\">Points</th>\\n    </tr>\\n\";\n  stack1 = helpers.each.call(depth0, depth0, {\"name\":\"each\",\"hash\":{},\"fn\":this.program(1, data),\"inverse\":this.noop,\"data\":data});\n  if (stack1 != null) { buffer += stack1; }\n  return buffer + \"  </table>\\n</div>\\n\";\n},\"useData\":true});\n\n},{\"hbsfy/runtime\":\"/Users/hoffmeyer/development/ranky/node_modules/hbsfy/runtime.js\"}]},{},[\"./client/rankyui.js\"]);\n"],"sourceRoot":"/source/"}